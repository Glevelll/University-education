# University-education

# [FileServer](https://github.com/Glevelll/University-education/tree/main/FileServer)

Этот код реализован для отправки, получения и удаления файлов с использованием сервера. Этот код реализован с использованием сокетов. Подробную задачу можно найти здесь https://hyperskill.org/projects/52/stages/286/implement

# [Lombok](https://github.com/Glevelll/University-education/tree/main/Lombok)

Все основные аннотации, которые предлагает lombok, применяются здесь.

# [Machines](https://github.com/Glevelll/University-education/tree/main/Machines)

## [Недетерминированный конечный автомат](https://github.com/Glevelll/University-education/tree/main/Machines/Machine)

В этом разделе обсуждается работа определенного недетерминированного конечного автомата.
![image](https://user-images.githubusercontent.com/113721736/215865928-63f2a50b-5661-44fb-a447-85c467c338de.png)
Как мы видим, у него 2 входных символа, 5 выходных символов и 4 состояния. Поскольку любой переход такого автомата однозначно определяется текущим состоянием и входным символом, где для каждого изменения состояния требуется чтение входного символа, то, проходя через каждое состояние, мы, при необходимости, заменим входные символы выходными и будем переходить по состояниям в соответствии с условиями, диктуемыми нашей машиной

## [Машина Тьюринга](https://github.com/Glevelll/University-education/tree/main/Machines/Turing)

Этот проект демонстрирует работу машины Тьюринга, которая выглядит следующим образом:
![image](https://user-images.githubusercontent.com/113721736/215868756-600dc010-c97d-4eb2-9c67-c1f73518ae68.png)
Имеется алфавит из 5 символов, 3 состояния и сама таблица, показывающая работу машины в направлении влево, вправо или оставаться на месте.
Стратегия, похожая на недетерминированный конечный автомат: замена символов по одному, за которой следует переход, который диктует машина.

## [Регулярное выражение](https://github.com/Glevelll/University-education/tree/main/Machines/Regular)

В этом случае из символов, указанных в коде, генерируется случайное регулярное выражение, которое, в свою очередь, записывается в файл. Чтобы создать допустимое регулярное выражение, программа рассматривает множество случаев, которые должны быть выполнены, прежде чем программа создаст окончательное регулярное выражение. Вот тут-то и возникает очевидная проблема: мы жертвуем временем выполнения программы. Но поскольку цель этого раздела — проиллюстрировать, что программист знаком с концепцией регулярного выражения, я прошу читателя закрыть глаза на эту маленькую неприятность :)

# [Spring Core](https://github.com/Glevelll/University-education/tree/main/SprngAntns)
Spring Core — это фреймворк разработки Java, который позволяет разрабатывать приложение как набор слабосвязанных компонентов. Чем меньше компоненты приложения знают друг о друге, тем проще разрабатывать новые и поддерживать существующую функциональность приложения. Spring состоит из множества аннотаций, которые упрощают работу с Java.

В файле sprngAnts вы можете найти реализацию Spring Core. В одной из папок под похожим названием реализация Spring аннотирована к классам, которые образуют систему, содержащую различные жанры фильмов, а также есть 3 варианта реализации воспроизведения фильмов: FilmPlayerWithConstructor, FilmPlayerWithSetter и, самый минималистичный, FilmPlayer.

В этом же файле вы можете найти папку Facade, которая содержит кинотеатр, построенный на шаблоне Facade (см. https://github.com/Glevelll/AdapterAndFacade), который включает Spring Core и связанные аннотации. В этом же файле есть папка Adapter, где также реализован Spring и к нему применен @Bean. @Bean отличается тем, что является синглтоном, а контейнер фреймворка Spring управляет созданием и установкой зависимостей bean-компонентов.

Также в качестве дополнительного материала для рассмотрения был взят Google Guice.

Guice устраняет необходимость в фабриках и использовании new в коде Java. В некоторых случаях вам придется писать фабрики, но код не будет напрямую зависеть от них. Guice упрощает изменение, тестирование и повторное использование кода в других контекстах.

# [Тестирование](https://github.com/Glevelll/University-education/tree/main/Testing/Calculator)

Этот проект демонстрирует тестирование калькулятора на JUnit5. Примитивный калькулятор умеет складывать, вычитать, умножать и делить. Тесты JUnit помогают проверить правильность вычислений.

# [emailProg](https://github.com/Glevelll/University-education/tree/main/emailProg)

Здесь вы можете найти код, который отправляет на указанную вами почту следующие данные: Название, погода в виде строки, дата, картинка и файл кода

# [Warships](https://github.com/Glevelll/University-education/tree/main/WarShips)

Консольная игра «Морской бой», написанная на двух языках: Java и Kotlin. Реализация на Kotlin предоставляет два варианта игры: с автодополнением и ручным заполнением поля

# [Генеалогическое дерево](https://github.com/Glevelll/University-education/tree/main/GenealogicalTree)

В этом репозитории демонстрируется работа с JavaFX для создания приятного пользовательского интерфейса для небольшого


# [RentBot](https://github.com/Glevelll/University-education/tree/main/RentBot)

Телеграм-бот для аренды помещени

Проект имеет 2 класса: Databases - класс для соединения с базой данных SQLite и, как следствие, для возможности записывать туда одни данные и получать из неё другие данные. RentBot - основной класс для реализации всех основных функций бота.

Команды для телеграм-бота реализованы в меню телеграм-бота и удобно вызываются при переписке с ботом.

Таблица Room нужна для хранения данных о помещениях. Название помещения должно быть уникальным. При заполнении помещения от лица админа с помощью бота, вместе с основной информацией фото добавляется в формате URL-ссылки в виде png, jpg и gif, не превышающее 2 мб.

Таблица User нужна для хранения данных о пользователях. Логин должен быть уникальным. Проверка на администратора происходит с помощью поля admin: если 1 - то это админ, в остальных случаях - обычный пользователь. Админ добавляется напрямую в бд, так как при регистрации нового пользователя, дефолтным значением в поле admin 0, так как регистрация не подразумевает, что каждый желающий может стать админом.

Таблица Book нужна для хранения данных о заявках на аренду. Здесь хранятся заявки на аренду, которые создаются или удаляются пользователем, а у админа есть возможность ответить на все заявки, статус которых "Не просмотрено"
